package com.hp.jipp.util

import java.util.concurrent.CancellationException
import java.util.concurrent.CopyOnWriteArrayList
import java.util.concurrent.ExecutorService
import java.util.concurrent.Future

/**
 * Encapsulates work that runs in the background, producing zero or more results and/or a terminating error.
 * Listeners may be added to handle results.
 *
 * The task is constructed in an unstarted state.
 */
abstract class Task<Result>(
    /** The executor for doing task work  */
    private val mWorkExecutor: ExecutorService,

    /** The executor for signaling listeners  */
    private val mListenExecutor: ExecutorService) {

    /** Listeners to be notified of interesting events  */
    private val mListeners = CopyOnWriteArrayList<Listener<Result>>()

    /** Future under which this task executes  */
    private var mFuture: Future<*>? = null

    /** Throwable describing how this task completed  */
    private var mCompletion: Throwable? = null

    /** Adds a listener to hear about all subsequent task results  */
    fun addListener(listener: Listener<Result>): Task<Result> {
        mListeners.add(listener)
        return this
    }

    /** Removes a listener so that it no longer hears about task results  */
    fun removeListener(listener: Listener<Result>): Task<Result> {
        mListeners.remove(listener)
        return this
    }

    /** Begins executing a task with a listener in place  */
    fun start(listener: Listener<Result>): Task<Result> {
        addListener(listener)
        start()
        return this
    }

    /** Begins executing in the background  */
    fun start(): Task<Result> {
        if (mFuture != null) throw IllegalStateException("already started")

        mFuture = mWorkExecutor.submit {
            try {
                this@Task.run()
                notifyDone()
            } catch (cancelled: InterruptedException) {
                notifyThrown(CANCELLATION)
            } catch (thrown: Throwable) {
                notifyThrown(thrown)
            }
        }
        return this
    }

    /** Do the work of the task, calling [submit] as often as necessary before returning */
    @Throws(Exception::class)
    protected abstract fun run()

    /**
     * Called to submit a new result object, causing any listeners to be notified
     */
    protected fun submit(value: Result) {
        mListenExecutor.submit(Runnable {
            // If an error was thrown then ignore subsequent results
            if (mCompletion != null) return@Runnable
            for (listener in mListeners) {
                listener.onResult(value)
            }
        })
    }

    private fun notifyDone() {
        mListenExecutor.submit(Runnable {
            if (mCompletion != null) return@Runnable
            // Assign a DONE code so no more notifications can occur
            mCompletion = DONE
            for (listener in mListeners) {
                listener.onDone()
            }
            mListeners.clear()
        })
    }

    private fun notifyThrown(thrown: Throwable) {
        mListenExecutor.submit(Runnable {
            // Throw one and only one error
            if (mCompletion != null) return@Runnable
            mCompletion = thrown
            for (listener in mListeners) {
                listener.onError(thrown)
            }
            mListeners.clear()
        })
    }

    /**
     * Request a running (or already-completed) task to stop. If successfully canceled, listeners are
     * notified with [Listener.onError] of [CANCELLATION].
     */
    fun cancel() {
        if (mFuture == null) throw IllegalStateException("Not started")
        if (mFuture!!.isCancelled) return
        if (mFuture!!.isDone) return

        if (mFuture!!.cancel(true)) {
            notifyThrown(CANCELLATION)
        }
    }

    /** A listener for results of a task with all callbacks to be dispatched by the listener service */
    interface Listener<Result> {
        /** Called when a result was generated by a task  */
        fun onResult(result: Result)

        /** Called when a task completes normally, with no further values to be generated */
        fun onDone()

        /** Called when a task completes with an error, with no further results to be generated */
        fun onError(thrown: Throwable)
    }

    /** A base class for task listeners with default empty behavior */
    abstract class BaseListener<Result> : Listener<Result> {
        override fun onResult(result: Result) {}

        override fun onDone() {}

        override fun onError(thrown: Throwable) {}
    }

    companion object {
        private val DONE = Exception()

        /** Exception thrown when a task is cancelled */
        @JvmField
        val CANCELLATION = CancellationException()
    }
}
