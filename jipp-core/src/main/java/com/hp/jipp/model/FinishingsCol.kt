// Copyright 2018 HP Development Company, L.P.
// SPDX-License-Identifier: MIT
//
// DO NOT MODIFY. Code is auto-generated by genTypes.py. Content taken from registry at
// https://www.iana.org/assignments/ipp-registrations/ipp-registrations.xml, updated on 2020-06-10
@file:Suppress("MaxLineLength", "WildcardImport")

package com.hp.jipp.model

import com.hp.jipp.encoding.* // ktlint-disable no-wildcard-imports

/**
 * Data object corresponding to a "finishings-col" collection as defined in:
 * [PWG5100.1](https://ftp.pwg.org/pub/pwg/candidates/cs-ippfinishings10-20010205-5100.1.pdf).
 */
@Suppress("RedundantCompanionReference", "unused")
data class FinishingsCol
constructor(
    var baling: Baling? = null,
    var binding: Binding? = null,
    var coating: Coating? = null,
    var covering: Covering? = null,
    /** May contain any keyword from [FinishingTemplate] or a name. */
    var finishingTemplate: KeywordOrName? = null,
    var folding: List<Folding>? = null,
    /** May contain any keyword from [ImpositionTemplate] or a name. */
    var impositionTemplate: KeywordOrName? = null,
    var laminating: Laminating? = null,
    var mediaSheetsSupported: IntRange? = null,
    var mediaSize: MediaSize? = null,
    /** May contain any keyword from [Media]. */
    var mediaSizeName: String? = null,
    var punching: Punching? = null,
    var stitching: Stitching? = null,
    var trimming: List<Trimming>? = null
) : AttributeCollection {

    /** Construct an empty [FinishingsCol]. */
    constructor() : this(null, null, null, null, null, null, null, null, null, null, null, null, null, null)

    /** Produce an attribute list from members. */
    override val attributes: List<Attribute<*>> by lazy {
        listOfNotNull(
            baling?.let { Types.baling.of(it) },
            binding?.let { Types.binding.of(it) },
            coating?.let { Types.coating.of(it) },
            covering?.let { Types.covering.of(it) },
            finishingTemplate?.let { Types.finishingTemplate.of(it) },
            folding?.let { Types.folding.of(it) },
            impositionTemplate?.let { Types.impositionTemplate.of(it) },
            laminating?.let { Types.laminating.of(it) },
            mediaSheetsSupported?.let { Types.mediaSheetsSupported.of(it) },
            mediaSize?.let { Types.mediaSize.of(it) },
            mediaSizeName?.let { Types.mediaSizeName.of(it) },
            punching?.let { Types.punching.of(it) },
            stitching?.let { Types.stitching.of(it) },
            trimming?.let { Types.trimming.of(it) }
        )
    }

    /** Types for each member attribute. */
    object Types {
        @JvmField val baling = AttributeCollection.Type("baling", Baling)
        @JvmField val binding = AttributeCollection.Type("binding", Binding)
        @JvmField val coating = AttributeCollection.Type("coating", Coating)
        @JvmField val covering = AttributeCollection.Type("covering", Covering)
        @JvmField val finishingTemplate = KeywordOrNameType("finishing-template")
        @JvmField val folding = AttributeCollection.SetType("folding", Folding)
        @JvmField val impositionTemplate = KeywordOrNameType("imposition-template")
        @JvmField val laminating = AttributeCollection.Type("laminating", Laminating)
        @JvmField val mediaSheetsSupported = IntRangeType("media-sheets-supported")
        @JvmField val mediaSize = AttributeCollection.Type("media-size", MediaSize)
        @JvmField val mediaSizeName = KeywordType("media-size-name")
        @JvmField val punching = AttributeCollection.Type("punching", Punching)
        @JvmField val stitching = AttributeCollection.Type("stitching", Stitching)
        @JvmField val trimming = AttributeCollection.SetType("trimming", Trimming)
    }

    /** Defines types for each member of [FinishingsCol]. */
    companion object : AttributeCollection.Converter<FinishingsCol> {
        override fun convert(attributes: List<Attribute<*>>): FinishingsCol =
            FinishingsCol(
                extractOne(attributes, Types.baling),
                extractOne(attributes, Types.binding),
                extractOne(attributes, Types.coating),
                extractOne(attributes, Types.covering),
                extractOne(attributes, Types.finishingTemplate),
                extractAll(attributes, Types.folding),
                extractOne(attributes, Types.impositionTemplate),
                extractOne(attributes, Types.laminating),
                extractOne(attributes, Types.mediaSheetsSupported),
                extractOne(attributes, Types.mediaSize),
                extractOne(attributes, Types.mediaSizeName),
                extractOne(attributes, Types.punching),
                extractOne(attributes, Types.stitching),
                extractAll(attributes, Types.trimming)
            )
    }

    /**
     * Data object corresponding to a "baling" collection.
     */
    @Suppress("RedundantCompanionReference", "unused")
    data class Baling
    constructor(
        /** May contain any keyword from [BalingType] or a name. */
        var balingType: KeywordOrName? = null,
        /** May contain any keyword from [BalingWhen]. */
        var balingWhen: String? = null
    ) : AttributeCollection {

        /** Construct an empty [Baling]. */
        constructor() : this(null, null)

        /** Produce an attribute list from members. */
        override val attributes: List<Attribute<*>> by lazy {
            listOfNotNull(
                balingType?.let { Types.balingType.of(it) },
                balingWhen?.let { Types.balingWhen.of(it) }
            )
        }

        /** Types for each member attribute. */
        object Types {
            @JvmField val balingType = KeywordOrNameType("baling-type")
            @JvmField val balingWhen = KeywordType("baling-when")
        }

        /** Defines types for each member of [Baling]. */
        companion object : AttributeCollection.Converter<Baling> {
            override fun convert(attributes: List<Attribute<*>>): Baling =
                Baling(
                    extractOne(attributes, Types.balingType),
                    extractOne(attributes, Types.balingWhen)
                )
        }
        override fun toString() = "Baling(${attributes.joinToString()})"
    }

    /**
     * Data object corresponding to a "binding" collection.
     */
    @Suppress("RedundantCompanionReference", "unused")
    data class Binding
    constructor(
        /** May contain any keyword from [BindingReferenceEdge]. */
        var bindingReferenceEdge: String? = null,
        /** May contain any keyword from [BindingType] or a name. */
        var bindingType: KeywordOrName? = null
    ) : AttributeCollection {

        /** Construct an empty [Binding]. */
        constructor() : this(null, null)

        /** Produce an attribute list from members. */
        override val attributes: List<Attribute<*>> by lazy {
            listOfNotNull(
                bindingReferenceEdge?.let { Types.bindingReferenceEdge.of(it) },
                bindingType?.let { Types.bindingType.of(it) }
            )
        }

        /** Types for each member attribute. */
        object Types {
            @JvmField val bindingReferenceEdge = KeywordType("binding-reference-edge")
            @JvmField val bindingType = KeywordOrNameType("binding-type")
        }

        /** Defines types for each member of [Binding]. */
        companion object : AttributeCollection.Converter<Binding> {
            override fun convert(attributes: List<Attribute<*>>): Binding =
                Binding(
                    extractOne(attributes, Types.bindingReferenceEdge),
                    extractOne(attributes, Types.bindingType)
                )
        }
        override fun toString() = "Binding(${attributes.joinToString()})"
    }

    /**
     * Data object corresponding to a "coating" collection.
     */
    @Suppress("RedundantCompanionReference", "unused")
    data class Coating
    constructor(
        /** May contain any keyword from [CoatingSides]. */
        var coatingSides: String? = null,
        /** May contain any keyword from [CoatingType] or a name. */
        var coatingType: KeywordOrName? = null
    ) : AttributeCollection {

        /** Construct an empty [Coating]. */
        constructor() : this(null, null)

        /** Produce an attribute list from members. */
        override val attributes: List<Attribute<*>> by lazy {
            listOfNotNull(
                coatingSides?.let { Types.coatingSides.of(it) },
                coatingType?.let { Types.coatingType.of(it) }
            )
        }

        /** Types for each member attribute. */
        object Types {
            @JvmField val coatingSides = KeywordType("coating-sides")
            @JvmField val coatingType = KeywordOrNameType("coating-type")
        }

        /** Defines types for each member of [Coating]. */
        companion object : AttributeCollection.Converter<Coating> {
            override fun convert(attributes: List<Attribute<*>>): Coating =
                Coating(
                    extractOne(attributes, Types.coatingSides),
                    extractOne(attributes, Types.coatingType)
                )
        }
        override fun toString() = "Coating(${attributes.joinToString()})"
    }

    /**
     * Data object corresponding to a "covering" collection.
     */
    @Suppress("RedundantCompanionReference", "unused")
    data class Covering
    constructor(
        /** May contain any keyword from [CoveringName] or a name. */
        var coveringName: KeywordOrName? = null
    ) : AttributeCollection {

        /** Construct an empty [Covering]. */
        constructor() : this(null)

        /** Produce an attribute list from members. */
        override val attributes: List<Attribute<*>> by lazy {
            listOfNotNull(
                coveringName?.let { Types.coveringName.of(it) }
            )
        }

        /** Types for each member attribute. */
        object Types {
            @JvmField val coveringName = KeywordOrNameType("covering-name")
        }

        /** Defines types for each member of [Covering]. */
        companion object : AttributeCollection.Converter<Covering> {
            override fun convert(attributes: List<Attribute<*>>): Covering =
                Covering(
                    extractOne(attributes, Types.coveringName)
                )
        }
        override fun toString() = "Covering(${attributes.joinToString()})"
    }

    /**
     * Data object corresponding to a "folding" collection.
     */
    @Suppress("RedundantCompanionReference", "unused")
    data class Folding
    constructor(
        /** May contain any keyword from [FoldingDirection]. */
        var foldingDirection: String? = null,
        var foldingOffset: Int? = null,
        /** May contain any keyword from [FoldingReferenceEdge]. */
        var foldingReferenceEdge: String? = null
    ) : AttributeCollection {

        /** Construct an empty [Folding]. */
        constructor() : this(null, null, null)

        /** Produce an attribute list from members. */
        override val attributes: List<Attribute<*>> by lazy {
            listOfNotNull(
                foldingDirection?.let { Types.foldingDirection.of(it) },
                foldingOffset?.let { Types.foldingOffset.of(it) },
                foldingReferenceEdge?.let { Types.foldingReferenceEdge.of(it) }
            )
        }

        /** Types for each member attribute. */
        object Types {
            @JvmField val foldingDirection = KeywordType("folding-direction")
            @JvmField val foldingOffset = IntType("folding-offset")
            @JvmField val foldingReferenceEdge = KeywordType("folding-reference-edge")
        }

        /** Defines types for each member of [Folding]. */
        companion object : AttributeCollection.Converter<Folding> {
            override fun convert(attributes: List<Attribute<*>>): Folding =
                Folding(
                    extractOne(attributes, Types.foldingDirection),
                    extractOne(attributes, Types.foldingOffset),
                    extractOne(attributes, Types.foldingReferenceEdge)
                )
        }
        override fun toString() = "Folding(${attributes.joinToString()})"
    }

    /**
     * Data object corresponding to a "laminating" collection.
     */
    @Suppress("RedundantCompanionReference", "unused")
    data class Laminating
    constructor(
        /** May contain any keyword from [LaminatingSides]. */
        var laminatingSides: String? = null,
        /** May contain any keyword from [LaminatingType] or a name. */
        var laminatingType: KeywordOrName? = null
    ) : AttributeCollection {

        /** Construct an empty [Laminating]. */
        constructor() : this(null, null)

        /** Produce an attribute list from members. */
        override val attributes: List<Attribute<*>> by lazy {
            listOfNotNull(
                laminatingSides?.let { Types.laminatingSides.of(it) },
                laminatingType?.let { Types.laminatingType.of(it) }
            )
        }

        /** Types for each member attribute. */
        object Types {
            @JvmField val laminatingSides = KeywordType("laminating-sides")
            @JvmField val laminatingType = KeywordOrNameType("laminating-type")
        }

        /** Defines types for each member of [Laminating]. */
        companion object : AttributeCollection.Converter<Laminating> {
            override fun convert(attributes: List<Attribute<*>>): Laminating =
                Laminating(
                    extractOne(attributes, Types.laminatingSides),
                    extractOne(attributes, Types.laminatingType)
                )
        }
        override fun toString() = "Laminating(${attributes.joinToString()})"
    }

    /**
     * Data object corresponding to a "media-size" collection.
     */
    @Suppress("RedundantCompanionReference", "unused")
    data class MediaSize
    constructor(
        var xDimension: Int? = null,
        var yDimension: Int? = null
    ) : AttributeCollection {

        /** Construct an empty [MediaSize]. */
        constructor() : this(null, null)

        /** Produce an attribute list from members. */
        override val attributes: List<Attribute<*>> by lazy {
            listOfNotNull(
                xDimension?.let { Types.xDimension.of(it) },
                yDimension?.let { Types.yDimension.of(it) }
            )
        }

        /** Types for each member attribute. */
        object Types {
            @JvmField val xDimension = IntType("x-dimension")
            @JvmField val yDimension = IntType("y-dimension")
        }

        /** Defines types for each member of [MediaSize]. */
        companion object : AttributeCollection.Converter<MediaSize> {
            override fun convert(attributes: List<Attribute<*>>): MediaSize =
                MediaSize(
                    extractOne(attributes, Types.xDimension),
                    extractOne(attributes, Types.yDimension)
                )
        }
        override fun toString() = "MediaSize(${attributes.joinToString()})"
    }

    /**
     * Data object corresponding to a "punching" collection.
     */
    @Suppress("RedundantCompanionReference", "unused")
    data class Punching
    constructor(
        var punchingLocations: List<Int>? = null,
        var punchingOffset: Int? = null,
        /** May contain any keyword from [PunchingReferenceEdge]. */
        var punchingReferenceEdge: String? = null
    ) : AttributeCollection {

        /** Construct an empty [Punching]. */
        constructor() : this(null, null, null)

        /** Produce an attribute list from members. */
        override val attributes: List<Attribute<*>> by lazy {
            listOfNotNull(
                punchingLocations?.let { Types.punchingLocations.of(it) },
                punchingOffset?.let { Types.punchingOffset.of(it) },
                punchingReferenceEdge?.let { Types.punchingReferenceEdge.of(it) }
            )
        }

        /** Types for each member attribute. */
        object Types {
            @JvmField val punchingLocations = IntType.Set("punching-locations")
            @JvmField val punchingOffset = IntType("punching-offset")
            @JvmField val punchingReferenceEdge = KeywordType("punching-reference-edge")
        }

        /** Defines types for each member of [Punching]. */
        companion object : AttributeCollection.Converter<Punching> {
            override fun convert(attributes: List<Attribute<*>>): Punching =
                Punching(
                    extractAll(attributes, Types.punchingLocations),
                    extractOne(attributes, Types.punchingOffset),
                    extractOne(attributes, Types.punchingReferenceEdge)
                )
        }
        override fun toString() = "Punching(${attributes.joinToString()})"
    }

    /**
     * Data object corresponding to a "stitching" collection.
     */
    @Suppress("RedundantCompanionReference", "unused")
    data class Stitching
    constructor(
        var stitchingAngle: Int? = null,
        var stitchingLocations: List<Int>? = null,
        /** May contain any keyword from [StitchingMethod]. */
        var stitchingMethod: String? = null,
        var stitchingOffset: Int? = null,
        /** May contain any keyword from [StitchingReferenceEdge]. */
        var stitchingReferenceEdge: String? = null
    ) : AttributeCollection {

        /** Construct an empty [Stitching]. */
        constructor() : this(null, null, null, null, null)

        /** Produce an attribute list from members. */
        override val attributes: List<Attribute<*>> by lazy {
            listOfNotNull(
                stitchingAngle?.let { Types.stitchingAngle.of(it) },
                stitchingLocations?.let { Types.stitchingLocations.of(it) },
                stitchingMethod?.let { Types.stitchingMethod.of(it) },
                stitchingOffset?.let { Types.stitchingOffset.of(it) },
                stitchingReferenceEdge?.let { Types.stitchingReferenceEdge.of(it) }
            )
        }

        /** Types for each member attribute. */
        object Types {
            @JvmField val stitchingAngle = IntType("stitching-angle")
            @JvmField val stitchingLocations = IntType.Set("stitching-locations")
            @JvmField val stitchingMethod = KeywordType("stitching-method")
            @JvmField val stitchingOffset = IntType("stitching-offset")
            @JvmField val stitchingReferenceEdge = KeywordType("stitching-reference-edge")
        }

        /** Defines types for each member of [Stitching]. */
        companion object : AttributeCollection.Converter<Stitching> {
            override fun convert(attributes: List<Attribute<*>>): Stitching =
                Stitching(
                    extractOne(attributes, Types.stitchingAngle),
                    extractAll(attributes, Types.stitchingLocations),
                    extractOne(attributes, Types.stitchingMethod),
                    extractOne(attributes, Types.stitchingOffset),
                    extractOne(attributes, Types.stitchingReferenceEdge)
                )
        }
        override fun toString() = "Stitching(${attributes.joinToString()})"
    }

    /**
     * Data object corresponding to a "trimming" collection.
     */
    @Suppress("RedundantCompanionReference", "unused")
    data class Trimming
    constructor(
        var trimmingOffset: Int? = null,
        /** May contain any keyword from [TrimmingReferenceEdge]. */
        var trimmingReferenceEdge: String? = null,
        /** May contain any keyword from [TrimmingType] or a name. */
        var trimmingType: KeywordOrName? = null,
        /** May contain any keyword from [TrimmingWhen]. */
        var trimmingWhen: String? = null
    ) : AttributeCollection {

        /** Construct an empty [Trimming]. */
        constructor() : this(null, null, null, null)

        /** Produce an attribute list from members. */
        override val attributes: List<Attribute<*>> by lazy {
            listOfNotNull(
                trimmingOffset?.let { Types.trimmingOffset.of(it) },
                trimmingReferenceEdge?.let { Types.trimmingReferenceEdge.of(it) },
                trimmingType?.let { Types.trimmingType.of(it) },
                trimmingWhen?.let { Types.trimmingWhen.of(it) }
            )
        }

        /** Types for each member attribute. */
        object Types {
            @JvmField val trimmingOffset = IntType("trimming-offset")
            @JvmField val trimmingReferenceEdge = KeywordType("trimming-reference-edge")
            @JvmField val trimmingType = KeywordOrNameType("trimming-type")
            @JvmField val trimmingWhen = KeywordType("trimming-when")
        }

        /** Defines types for each member of [Trimming]. */
        companion object : AttributeCollection.Converter<Trimming> {
            override fun convert(attributes: List<Attribute<*>>): Trimming =
                Trimming(
                    extractOne(attributes, Types.trimmingOffset),
                    extractOne(attributes, Types.trimmingReferenceEdge),
                    extractOne(attributes, Types.trimmingType),
                    extractOne(attributes, Types.trimmingWhen)
                )
        }
        override fun toString() = "Trimming(${attributes.joinToString()})"
    }
    override fun toString() = "FinishingsCol(${attributes.joinToString()})"
}
